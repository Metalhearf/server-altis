//
// SessionPool.cpp
//
// $Id: //poco/1.4/Data/src/SessionPool.cpp#2 $
//
// Library: Data
// Package: SessionPooling
// Module:  SessionPool
//
// Copyright (c) 2006, Applied Informatics Software Engineering GmbH.
// and Contributors.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//


#include "Poco/Data/SessionPool.h"
#include "Poco/Data/SessionFactory.h"
#include "Poco/Data/DataException.h"
#include <algorithm>
#include <utility>


namespace Poco {
namespace Data {


SessionPool::SessionPool(const std::string& sessionKey, const std::string& connectionString, int minSessions, int maxSessions, int idleTime):
	_sessionKey(sessionKey),
	_connectionString(connectionString),
	_minSessions(minSessions),
	_maxSessions(maxSessions),
	_idleTime(idleTime),
	_nSessions(0),
	_janitorTimer(1000*idleTime, 1000*idleTime/4)
{
	Poco::TimerCallback<SessionPool> callback(*this, &SessionPool::onJanitorTimer);
	if (_idleTime > 0) _janitorTimer.start(callback);
}


SessionPool::~SessionPool()
{
	try
	{
		if (_idleTime > 0) _janitorTimer.stop();
	}
	catch (...)
	{
		poco_unexpected();
	}
}


Session SessionPool::get()
{
	Poco::FastMutex::ScopedLock lock(_mutex);
	
	purgeDeadSessions();

	if (_nSessions < _maxSessions)
	{
		Session newSession(SessionFactory::instance().create(_sessionKey, _connectionString));
		customizeSession(newSession);
		
		PooledSessionHolderPtr pHolder(new PooledSessionHolder(*this, newSession.impl()));
		SessionDataPtr session_data_ptr(new SessionData);
		session_data_ptr->session = pHolder;

		_idleSessions.push_front(session_data_ptr);
		++_nSessions;
	}
	PooledSessionHolderPtr pHolder(_idleSessions.front()->session);
	PooledSessionImplPtr pPSI(new PooledSessionImpl(pHolder));
	
	_activeSessions.push_front(std::move(_idleSessions.front()));
	_idleSessions.pop_front();

	return Session(pPSI);
}


Session SessionPool::get(SessionPool::SessionDataPtr &session_data_ptr)
{
	Poco::FastMutex::ScopedLock lock(_mutex);
	
	purgeDeadSessions();

	if (_nSessions < _maxSessions)
	{
		Session newSession(SessionFactory::instance().create(_sessionKey, _connectionString));
		customizeSession(newSession);
		
		PooledSessionHolderPtr pHolder(new PooledSessionHolder(*this, newSession.impl()));
		session_data_ptr.assign(new SessionData);
		session_data_ptr->session = pHolder;

		_idleSessions.push_front(session_data_ptr);
		++_nSessions;
	}
	PooledSessionHolderPtr pHolder(_idleSessions.front()->session);
	PooledSessionImplPtr pPSI(new PooledSessionImpl(pHolder));
	
	_activeSessions.push_front(std::move(_idleSessions.front()));
	_idleSessions.pop_front();
	
	if (session_data_ptr.isNull())
	{
		session_data_ptr.assign(_activeSessions.front());
	}

	return Session(pPSI);
}


void SessionPool::purgeDeadSessions()
{
	SessionList::iterator it = _idleSessions.begin();
	for (; it != _idleSessions.end(); )
	{
		if (!(*it)->session->session()->isConnected())
		{
			it = _idleSessions.erase(it);
			--_nSessions;
		}
		else ++it;
	}
}


int SessionPool::capacity() const
{
	return _maxSessions;
}

	
int SessionPool::used() const
{
	Poco::FastMutex::ScopedLock lock(_mutex);

	return (int) _activeSessions.size();
}

	
int SessionPool::idle() const
{
	Poco::FastMutex::ScopedLock lock(_mutex);

	return (int) _idleSessions.size();
}


int SessionPool::dead()
{
	Poco::FastMutex::ScopedLock lock(_mutex);

	int count = 0;

	SessionList::iterator it = _activeSessions.begin();
	SessionList::iterator itEnd = _activeSessions.end();
	for (; it != itEnd; ++it)
	{
		if (!(*it)->session->session()->isConnected())
			++count;
	}

	return count;
}


int SessionPool::allocated() const
{
	Poco::FastMutex::ScopedLock lock(_mutex);
	
	return _nSessions;
}

	
int SessionPool::available() const
{
	return _maxSessions - used();
}


void SessionPool::customizeSession(Session&)
{
}


void SessionPool::putBack(PooledSessionHolderPtr pHolder)
{
	Poco::FastMutex::ScopedLock lock(_mutex);

	for (SessionList::iterator it = _activeSessions.begin(); it != _activeSessions.end(); ++it)
	{
		if ((*it)->session == pHolder)
		{
			if (pHolder->session()->isConnected())
			{
				pHolder->access();
				_idleSessions.push_front(std::move(*it));
			}
			else
			{
				--_nSessions;
			};
			_activeSessions.erase(it);
			break;
		}
	}
}


void SessionPool::onJanitorTimer(Poco::Timer&)
{
	Poco::FastMutex::ScopedLock lock(_mutex);
	
	SessionList::iterator it = _idleSessions.begin(); 
	while (_nSessions > _minSessions && it != _idleSessions.end())
	{
		if ((*it)->session->idle() > _idleTime || !(*it)->session->session()->isConnected())
		{	
			try
			{
				(*it)->session->session()->close();
			}
			catch (...)
			{			
			}
			it = _idleSessions.erase(it);
			--_nSessions;
		}
		else ++it;
	}
}


} } // namespace Poco::Data
